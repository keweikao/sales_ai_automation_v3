# 模組化架構重構規劃

> 建立日期：2026-01-29
> 目標：提升專案的可擴展性、可測試性、服務抽換便利性

---

## 參考資源

### 推薦 Git Repositories

| Repository | 特色 | 適用場景 |
|------------|------|----------|
| [domain-driven-hexagon](https://github.com/Sairyss/domain-driven-hexagon) | 最完整的 DDD + 六角架構範例，含詳細文件 | 整體架構設計參考 |
| [typescript-clean-architecture](https://github.com/bypepe77/typescript-clean-architecture) | 使用 tsyringe DI，SOLID 原則示範 | 依賴注入實作參考 |
| [hexagonal-example](https://github.com/onicagroup/hexagonal-example) | 輕量 AWS Lambda + DynamoDB 範例 | Serverless 架構參考 |
| [nestjs-clean-example](https://github.com/0xTheProDev/nestjs-clean-example) | Repository Pattern 完整示範 | Service 層分離參考 |

### 推薦 DI 函式庫

| Library | 特色 | Stars |
|---------|------|-------|
| [tsyringe](https://github.com/microsoft/tsyringe) | Microsoft 出品，輕量、裝飾器注入 | 5.1k |
| [typed-inject](https://github.com/nicojs/typed-inject) | 100% 型別安全，編譯時驗證 | 400+ |
| [clawject](https://github.com/clawject/clawject) | AOT 編譯，零運行時開銷 | 新興 |

**建議**：考量 Cloudflare Workers 環境，推薦使用**手動 DI**或 **typed-inject**（不依賴裝飾器反射）

---

## 一、Service 層分離

### 目標

將業務邏輯從 API 路由層抽離，建立獨立的 Service 層。

### 目前問題

```typescript
// packages/api/src/routers/opportunity.ts (現況)
export const createOpportunity = protectedProcedure
  .handler(async ({ input, context }) => {
    // ❌ 直接操作 DB
    const result = await db.insert(opportunities).values({...});

    // ❌ 快取邏輯混在路由層
    await invalidateOpportunitiesCache(cacheService, userId);

    return result;
  });
```

### 目標架構

```
packages/
├── services/
│   └── src/
│       ├── opportunity/           # 新增
│       │   ├── opportunity.service.ts
│       │   ├── opportunity.repository.ts
│       │   └── index.ts
│       ├── conversation/          # 新增
│       │   ├── conversation.service.ts
│       │   ├── conversation.repository.ts
│       │   └── index.ts
│       └── ...
```

### 實作範例

```typescript
// packages/services/src/opportunity/opportunity.repository.ts
import type { Database } from "@sales_ai_automation_v3/db";
import { opportunities } from "@sales_ai_automation_v3/db/schema";
import { eq } from "drizzle-orm";

export interface OpportunityRepository {
  findById(id: string): Promise<Opportunity | null>;
  findByUserId(userId: string): Promise<Opportunity[]>;
  create(data: CreateOpportunityInput): Promise<Opportunity>;
  update(id: string, data: UpdateOpportunityInput): Promise<Opportunity>;
  delete(id: string): Promise<void>;
}

export function createOpportunityRepository(db: Database): OpportunityRepository {
  return {
    async findById(id: string) {
      const [result] = await db
        .select()
        .from(opportunities)
        .where(eq(opportunities.id, id))
        .limit(1);
      return result ?? null;
    },

    async findByUserId(userId: string) {
      return db
        .select()
        .from(opportunities)
        .where(eq(opportunities.userId, userId));
    },

    async create(data: CreateOpportunityInput) {
      const [result] = await db
        .insert(opportunities)
        .values({ id: randomUUID(), ...data })
        .returning();
      return result;
    },

    async update(id: string, data: UpdateOpportunityInput) {
      const [result] = await db
        .update(opportunities)
        .set({ ...data, updatedAt: new Date() })
        .where(eq(opportunities.id, id))
        .returning();
      return result;
    },

    async delete(id: string) {
      await db.delete(opportunities).where(eq(opportunities.id, id));
    },
  };
}
```

```typescript
// packages/services/src/opportunity/opportunity.service.ts
import type { OpportunityRepository } from "./opportunity.repository";
import type { CacheService } from "../cache/types";
import type { Logger } from "../logger/types";
import { AppError, errors } from "@sales_ai_automation_v3/shared";

export interface OpportunityService {
  create(input: CreateOpportunityInput, userId: string): Promise<Opportunity>;
  getById(id: string, userId: string): Promise<Opportunity>;
  listByUser(userId: string): Promise<Opportunity[]>;
  updateStage(id: string, stage: OpportunityStage, userId: string): Promise<Opportunity>;
}

export interface OpportunityServiceDeps {
  repository: OpportunityRepository;
  cache: CacheService;
  logger: Logger;
}

export function createOpportunityService(deps: OpportunityServiceDeps): OpportunityService {
  const { repository, cache, logger } = deps;

  return {
    async create(input, userId) {
      logger.info("Creating opportunity", { userId, customerNumber: input.customerNumber });

      const opportunity = await repository.create({ ...input, userId });

      // 快取失效
      await cache.delete(`opportunities:${userId}`);

      logger.info("Opportunity created", { opportunityId: opportunity.id });
      return opportunity;
    },

    async getById(id, userId) {
      const opportunity = await repository.findById(id);

      if (!opportunity) {
        throw errors.OPPORTUNITY_NOT_FOUND(id);
      }

      if (opportunity.userId !== userId) {
        throw errors.UNAUTHORIZED("無權限存取此商機");
      }

      return opportunity;
    },

    async listByUser(userId) {
      const cacheKey = `opportunities:${userId}`;

      // 嘗試從快取取得
      const cached = await cache.get<Opportunity[]>(cacheKey);
      if (cached) {
        logger.debug("Cache hit", { cacheKey });
        return cached;
      }

      const opportunities = await repository.findByUserId(userId);

      // 寫入快取
      await cache.set(cacheKey, opportunities, { ttl: 300 });

      return opportunities;
    },

    async updateStage(id, stage, userId) {
      const opportunity = await this.getById(id, userId);

      // 業務邏輯：驗證狀態轉換
      if (!isValidStageTransition(opportunity.stage, stage)) {
        throw new AppError(
          "VALIDATION_ERROR",
          `無法從 ${opportunity.stage} 轉換到 ${stage}`,
          400
        );
      }

      const updated = await repository.update(id, { stage });
      await cache.delete(`opportunities:${userId}`);

      return updated;
    },
  };
}

function isValidStageTransition(from: string, to: string): boolean {
  const transitions: Record<string, string[]> = {
    discovery: ["demo_scheduled", "lost"],
    demo_scheduled: ["demo_completed", "lost"],
    demo_completed: ["proposal", "lost"],
    proposal: ["negotiation", "lost"],
    negotiation: ["won", "lost"],
  };
  return transitions[from]?.includes(to) ?? false;
}
```

```typescript
// packages/api/src/routers/opportunity.ts (重構後)
export const createOpportunity = protectedProcedure
  .input(createOpportunitySchema)
  .handler(async ({ input, context }) => {
    // ✅ 只負責呼叫 Service
    return context.services.opportunity.create(input, context.userId);
  });

export const getOpportunity = protectedProcedure
  .input(z.object({ id: z.string() }))
  .handler(async ({ input, context }) => {
    return context.services.opportunity.getById(input.id, context.userId);
  });
```

### 遷移策略

1. **Phase 1**：建立 Service 層基礎結構（1 天）
2. **Phase 2**：遷移 Opportunity 模組作為範例（1 天）
3. **Phase 3**：新功能一律使用 Service 層
4. **Phase 4**：逐步遷移其他模組（持續進行）

---

## 二、錯誤處理標準化

### 目前現況

已有 `packages/shared/src/errors/index.ts`，但可以進一步完善：

### 改善項目

```typescript
// packages/shared/src/errors/index.ts (增強版)

// 1. 新增更多錯誤類型
export type ErrorCode =
  | "AUDIO_TOO_LARGE"
  | "INVALID_AUDIO_FORMAT"
  | "FILE_DOWNLOAD_FAILED"
  | "TRANSCRIPTION_FAILED"
  | "TRANSCRIPTION_TIMEOUT"
  | "GROQ_API_ERROR"
  | "GEMINI_API_ERROR"
  | "DATABASE_ERROR"
  | "RECORD_NOT_FOUND"
  | "OPPORTUNITY_NOT_FOUND"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "VALIDATION_ERROR"        // 新增
  | "EXTERNAL_SERVICE_ERROR"  // 新增
  | "RATE_LIMITED"            // 新增
  | "CONFLICT"                // 新增
  | "UNKNOWN_ERROR";

// 2. 新增 Result 型別（用於不想 throw 的情況）
export type Result<T, E = AppError> =
  | { ok: true; value: T }
  | { ok: false; error: E };

export const Result = {
  ok: <T>(value: T): Result<T, never> => ({ ok: true, value }),
  err: <E>(error: E): Result<never, E> => ({ ok: false, error }),
};

// 3. 新增錯誤工廠
export const errors = {
  // ... 現有的 ...

  // 新增
  VALIDATION_ERROR: (field: string, reason: string) =>
    new AppError(
      "VALIDATION_ERROR",
      `${field}: ${reason}`,
      400,
      undefined,
      { field, reason }
    ),

  EXTERNAL_SERVICE_ERROR: (service: string, originalError?: unknown) =>
    new AppError(
      "EXTERNAL_SERVICE_ERROR",
      `外部服務 ${service} 發生錯誤`,
      502,
      originalError,
      { service }
    ),

  RATE_LIMITED: (service: string, retryAfter?: number) =>
    new AppError(
      "RATE_LIMITED",
      `${service} 請求過於頻繁，請稍後再試`,
      429,
      undefined,
      { service, retryAfter }
    ),

  CONFLICT: (resource: string, reason: string) =>
    new AppError(
      "CONFLICT",
      `${resource} 衝突: ${reason}`,
      409,
      undefined,
      { resource, reason }
    ),
} as const;

// 4. 錯誤處理 Middleware
export function createErrorHandler(logger: Logger) {
  return async (error: unknown, c: Context) => {
    const requestId = c.get("requestId");

    if (isAppError(error)) {
      logger.warn("Application error", {
        requestId,
        code: error.code,
        message: error.message,
        context: error.context,
      });

      return c.json(
        {
          error: {
            code: error.code,
            message: error.message,
            requestId,
          },
        },
        error.statusCode as any
      );
    }

    // 未預期的錯誤
    logger.error("Unexpected error", {
      requestId,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });

    return c.json(
      {
        error: {
          code: "UNKNOWN_ERROR",
          message: "發生未預期的錯誤",
          requestId,
        },
      },
      500
    );
  };
}
```

---

## 三、結構化日誌

### 目標

統一日誌格式，加入 Request ID 追蹤。

### 實作

```typescript
// packages/shared/src/logger/index.ts (新增)

export type LogLevel = "debug" | "info" | "warn" | "error";

export interface LogContext {
  requestId?: string;
  service: string;
  userId?: string;
  [key: string]: unknown;
}

export interface Logger {
  debug(message: string, data?: Record<string, unknown>): void;
  info(message: string, data?: Record<string, unknown>): void;
  warn(message: string, data?: Record<string, unknown>): void;
  error(message: string, error?: Error, data?: Record<string, unknown>): void;
  child(context: Partial<LogContext>): Logger;
}

export interface LogEntry {
  level: LogLevel;
  timestamp: string;
  service: string;
  requestId?: string;
  userId?: string;
  message: string;
  data?: Record<string, unknown>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

export function createLogger(context: LogContext): Logger {
  const log = (level: LogLevel, message: string, data?: Record<string, unknown>, error?: Error) => {
    const entry: LogEntry = {
      level,
      timestamp: new Date().toISOString(),
      service: context.service,
      requestId: context.requestId,
      userId: context.userId,
      message,
      data,
    };

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
      };
    }

    // Cloudflare Workers 環境用 console
    const output = JSON.stringify(entry);
    switch (level) {
      case "debug":
        console.debug(output);
        break;
      case "info":
        console.info(output);
        break;
      case "warn":
        console.warn(output);
        break;
      case "error":
        console.error(output);
        break;
    }
  };

  return {
    debug: (message, data) => log("debug", message, data),
    info: (message, data) => log("info", message, data),
    warn: (message, data) => log("warn", message, data),
    error: (message, error, data) => log("error", message, data, error),
    child: (childContext) =>
      createLogger({ ...context, ...childContext }),
  };
}

// Middleware
export function loggerMiddleware(service: string) {
  return async (c: Context, next: () => Promise<void>) => {
    const requestId = c.req.header("x-request-id") || crypto.randomUUID();
    const logger = createLogger({ service, requestId });

    c.set("requestId", requestId);
    c.set("logger", logger);

    const start = Date.now();

    logger.info("Request started", {
      method: c.req.method,
      path: c.req.path,
      userAgent: c.req.header("user-agent"),
    });

    await next();

    const duration = Date.now() - start;

    logger.info("Request completed", {
      status: c.res.status,
      duration,
    });
  };
}
```

### 日誌輸出範例

```json
{
  "level": "info",
  "timestamp": "2026-01-29T10:30:00.000Z",
  "service": "api",
  "requestId": "abc-123-def",
  "userId": "user_456",
  "message": "Creating opportunity",
  "data": {
    "customerNumber": "202601-000001",
    "productLine": "ichef"
  }
}

{
  "level": "error",
  "timestamp": "2026-01-29T10:30:01.000Z",
  "service": "queue-worker",
  "requestId": "abc-123-def",
  "message": "Transcription failed",
  "data": {
    "fileId": "file_789",
    "duration": 180
  },
  "error": {
    "name": "GroqError",
    "message": "Rate limited",
    "stack": "..."
  }
}
```

---

## 四、依賴注入

### 選擇：手動 DI（Simple Container）

考量 Cloudflare Workers 環境限制，採用簡單的手動 DI。

```typescript
// packages/shared/src/container/index.ts (新增)

export type Factory<T> = (container: Container) => T;

export class Container {
  private factories = new Map<string, Factory<unknown>>();
  private instances = new Map<string, unknown>();

  register<T>(key: string, factory: Factory<T>): this {
    this.factories.set(key, factory);
    return this;
  }

  resolve<T>(key: string): T {
    // Singleton pattern
    if (this.instances.has(key)) {
      return this.instances.get(key) as T;
    }

    const factory = this.factories.get(key);
    if (!factory) {
      throw new Error(`Service "${key}" not registered`);
    }

    const instance = factory(this) as T;
    this.instances.set(key, instance);
    return instance;
  }

  // 建立新的 scope（用於 request-scoped 服務）
  createScope(): Container {
    const scoped = new Container();
    scoped.factories = new Map(this.factories);
    return scoped;
  }
}

// 型別安全的 Key 定義
export const ServiceKeys = {
  // Infrastructure
  DATABASE: "database",
  CACHE: "cache",
  LOGGER: "logger",

  // External Services
  GEMINI: "gemini",
  GROQ_WHISPER: "groqWhisper",
  R2_STORAGE: "r2Storage",
  SLACK: "slack",

  // Business Services
  OPPORTUNITY_REPO: "opportunityRepository",
  OPPORTUNITY_SERVICE: "opportunityService",
  CONVERSATION_REPO: "conversationRepository",
  CONVERSATION_SERVICE: "conversationService",
} as const;
```

### 設定範例

```typescript
// apps/server/src/container.ts

import { Container, ServiceKeys } from "@sales_ai_automation_v3/shared";
import { createDbClient } from "@sales_ai_automation_v3/db";
import {
  createGeminiClient,
  createGroqWhisperService,
  createR2Service,
  createKVCacheService,
  createOpportunityRepository,
  createOpportunityService,
} from "@sales_ai_automation_v3/services";

export function createContainer(env: Env): Container {
  const container = new Container();

  // Infrastructure
  container.register(ServiceKeys.DATABASE, () =>
    createDbClient(env.DATABASE_URL)
  );

  container.register(ServiceKeys.CACHE, () =>
    createKVCacheService(env.CACHE_KV)
  );

  // External Services
  container.register(ServiceKeys.GEMINI, () =>
    createGeminiClient(env.GEMINI_API_KEY)
  );

  container.register(ServiceKeys.GROQ_WHISPER, () =>
    createGroqWhisperService(env.GROQ_API_KEY)
  );

  container.register(ServiceKeys.R2_STORAGE, () =>
    createR2Service({
      bucket: env.R2_BUCKET,
      accessKey: env.R2_ACCESS_KEY,
      secretKey: env.R2_SECRET_KEY,
    })
  );

  // Repositories
  container.register(ServiceKeys.OPPORTUNITY_REPO, (c) =>
    createOpportunityRepository(c.resolve(ServiceKeys.DATABASE))
  );

  // Business Services
  container.register(ServiceKeys.OPPORTUNITY_SERVICE, (c) =>
    createOpportunityService({
      repository: c.resolve(ServiceKeys.OPPORTUNITY_REPO),
      cache: c.resolve(ServiceKeys.CACHE),
      logger: c.resolve(ServiceKeys.LOGGER),
    })
  );

  return container;
}

// 在 API Context 中使用
export function createRequestContext(env: Env, requestId: string) {
  const container = createContainer(env);
  const logger = createLogger({ service: "api", requestId });

  // 註冊 request-scoped 服務
  container.register(ServiceKeys.LOGGER, () => logger);

  return {
    services: {
      opportunity: container.resolve<OpportunityService>(ServiceKeys.OPPORTUNITY_SERVICE),
      // ... 其他服務
    },
    logger,
    requestId,
  };
}
```

---

## 五、Claude SKILL 自動化

將架構檢查整合到現有的 SKILL 系統。

### 新增 SKILL：`/architecture-check`

```markdown
<!-- 加入 CLAUDE.md -->

### 架構品質類（重構/新功能時自動執行）

| Skill | 自動觸發時機 | 功能 |
|-------|-------------|------|
| `architecture-check` | 新增/修改 API 路由時 | 檢查是否違反 Service 層分離原則 |
| `di-check` | 新增服務時 | 檢查依賴注入是否正確設定 |
```

### SKILL 定義

在 `.claude/skills/` 目錄下建立：

```markdown
<!-- .claude/skills/architecture-check.md -->

# Architecture Check Skill

## 觸發條件
- 新增或修改 `packages/api/src/routers/**/*.ts`
- 新增或修改 `apps/*/src/**/*.ts`

## 檢查項目

### 1. Service 層分離
檢查 API 路由是否直接操作 DB：

```typescript
// ❌ 違規模式
await db.insert(...)
await db.update(...)
await db.delete(...)
await db.select(...)

// ✅ 正確模式
await context.services.xxx.method()
await xxxService.method()
```

### 2. 錯誤處理
檢查是否使用標準化錯誤：

```typescript
// ❌ 違規模式
throw new Error("...")
return { error: "..." }

// ✅ 正確模式
throw errors.RECORD_NOT_FOUND(...)
throw new AppError(...)
```

### 3. 日誌使用
檢查是否使用結構化日誌：

```typescript
// ❌ 違規模式
console.log(...)
console.error(...)

// ✅ 正確模式
logger.info(...)
logger.error(...)
```

## 輸出格式

```
## 架構檢查結果

### Service 層分離
- ✅ 通過 / ❌ 發現 N 處違規

### 錯誤處理
- ✅ 通過 / ❌ 發現 N 處違規

### 日誌使用
- ✅ 通過 / ❌ 發現 N 處違規

### 建議修正
1. [具體修正建議]
2. [具體修正建議]
```
```

### 更新 CLAUDE.md

```markdown
<!-- 加入自動執行規則 -->

### 自動執行規則

1. **完成功能開發後**：自動執行 `code-review` + `typescript-quality`
2. **準備 commit 前**：自動執行 `secret-scanner` + `tdd-guard`
3. **建立 PR 前**：自動執行 `pr-review`（包含上述所有檢查）
4. **涉及用戶輸入/資料庫**：自動執行 `security-audit`
5. **新增/修改 API 路由時**：自動執行 `architecture-check` <!-- 新增 -->

### 手動觸發

```
/architecture-check   # 手動執行架構檢查
```
```

---

## 六、實作時程建議

| 週次 | 工作項目 | 產出 |
|------|---------|------|
| Week 1 | 基礎建設 | Logger、Container、Error 增強 |
| Week 2 | Service 層範例 | Opportunity Service 完整實作 |
| Week 3 | SKILL 設定 | architecture-check 自動化 |
| Week 4+ | 持續遷移 | 每個新功能套用新架構 |

---

## 七、驗收標準

- [ ] 新的 API 路由不直接操作 DB
- [ ] 所有錯誤使用 AppError
- [ ] 所有日誌使用 Logger（有 requestId）
- [ ] Service 有對應的 Repository
- [ ] Container 正確註冊所有服務
- [ ] architecture-check SKILL 可正常執行

---

## 附錄：目錄結構（重構後）

```
packages/
├── shared/
│   └── src/
│       ├── errors/          # 錯誤處理（增強）
│       │   └── index.ts
│       ├── logger/          # 結構化日誌（新增）
│       │   ├── index.ts
│       │   └── types.ts
│       ├── container/       # DI Container（新增）
│       │   └── index.ts
│       └── ...
│
├── services/
│   └── src/
│       ├── opportunity/     # 業務服務（新增）
│       │   ├── opportunity.service.ts
│       │   ├── opportunity.repository.ts
│       │   └── index.ts
│       ├── conversation/    # 業務服務（新增）
│       │   ├── conversation.service.ts
│       │   ├── conversation.repository.ts
│       │   └── index.ts
│       ├── llm/             # 外部服務（現有）
│       ├── storage/         # 外部服務（現有）
│       └── ...
│
├── api/
│   └── src/
│       ├── routers/         # 薄路由層
│       ├── context.ts       # Request Context
│       └── container.ts     # DI 設定
```
